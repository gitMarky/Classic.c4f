/**
	Pipe line

<<<<<<< HEAD
	Author: ST-DDT, Marky
--*/

local Name = "$Name$";

local pipe_kit;

local ActMap = {
	Connect = {
		Prototype = Action,
		Name = "Connect",
		Procedure = DFA_CONNECT,
		NextAction = "Connect"
	}
};
=======
	@author ST-DDT
*/
>>>>>>> origin/master

private func Initialize()
{
	SetAction("Connect");
	SetVertexXY(0, GetX(), GetY());
	SetVertexXY(1, GetX(), GetY());
	SetNeutral();
}

// Greyish colour
public func SetNeutral()
{
	SetProperty("LineColors", [RGB(80, 80, 120), RGB(80, 80, 120)]);
}

// Reddish colour.
public func SetDrain()
{
	SetProperty("LineColors", [RGB(110, 80, 80), RGB(110, 80, 80)]);
}

// Greenish colour.
public func SetSource()
{
	SetProperty("LineColors", [RGB(80, 110, 80), RGB(80, 110, 80)]);
}

// Returns true if this object is a functioning pipe.
public func IsPipeLine()
{
	return GetAction() == "Connect";
}

<<<<<<< HEAD
/** Returns whether this pipe is connected to an object.
    Returns only actually connected objects if the parameter 'strict' is true */
public func IsConnectedTo(object obj, bool strict)
=======
// Returns whether this pipe is connected to an object.
public func IsConnectedTo(object obj)
>>>>>>> origin/master
{
	return GetActionTarget(0) == obj || GetActionTarget(1) == obj || (!strict && pipe_kit == obj);
}

<<<<<<< HEAD

/** Returns the object which is connected to obj through this pipe. */
=======
// Returns the object which is connected to obj through this pipe.
>>>>>>> origin/master
public func GetConnectedObject(object obj)
{
	if (GetActionTarget(0) == obj)
		return GetActionTarget(1);
	if (GetActionTarget(1) == obj)
		return GetActionTarget(0);
	return;
}

<<<<<<< HEAD
/** Switches connection from one object to another. */
public func SwitchConnection(object connected_to, object obj)
{
	var target0 = GetActionTarget(0), target1 = GetActionTarget(1);

	if (target0 == connected_to) target0 = obj;
	if (target1 == connected_to) target1 = obj;
	
	SetActionTargets(target0, target1);
}

/** Saves the pipe object that created this line. */
public func SetPipeKit(object obj)
{
	pipe_kit = obj;
}

public func GetPipeKit()
{
	if (pipe_kit)
	{
		return pipe_kit;
	}
	else
	{
		FatalError("Unexpected error: This pipe has lost its pipe kit!");
	}
}


private func LineBreak(bool no_msg)
=======
private func OnLineBreak(bool no_msg)
>>>>>>> origin/master
{
	Sound("Objects::LineSnap");
	if (!no_msg)
		BreakMessage();

<<<<<<< HEAD
	if (GetPipeKit())
	{
		GetPipeKit()->SetNeutralPipe();
		if (GetActionTarget(0)) GetActionTarget(0)->OnPipeDisconnect(GetPipeKit());
		if (GetActionTarget(1)) GetActionTarget(1)->OnPipeDisconnect(GetPipeKit());
	}
	
=======
	var line_end = GetActionTarget(0);
	if (!line_end ||line_end->GetID() != Pipe)
		line_end = GetActionTarget(1);
	if (line_end) 
		line_end->~OnPipeLineRemoval();
	return;
}

private func OnLineChange()
{
	// Notify action targets about line change.
	var act1 = GetActionTarget(0);
	var act2 = GetActionTarget(1);	
	if (act1) act1->~OnPipeLengthChange(this);
	if (act2) act2->~OnPipeLengthChange(this);
	
	// Break line if it is too long.
	if (GetPipeLength() > this.PipeMaxLength)
	{
		OnLineBreak();
		RemoveObject();
	}
>>>>>>> origin/master
	return;
}

// Returns the length between all the vertices.
public func GetPipeLength()
{
	var current_length = 0;
	for (var index = 0; index < GetVertexNum() - 1; index++)
		current_length += Distance(GetVertex(index, VTX_X), GetVertex(index, VTX_Y), GetVertex(index + 1, VTX_X), GetVertex(index + 1, VTX_Y));
	return current_length;
}

private func Destruction()
{
<<<<<<< HEAD
	var line_end = GetPipeKit();
	if (line_end) line_end->SetNeutralPipe();
=======
	var line_end = GetActionTarget(0);
	if (!line_end || line_end->GetID() != Pipe)
		line_end = GetActionTarget(1);
	if (line_end) 
		line_end->~OnPipeLineRemoval();
>>>>>>> origin/master
	return;
}

private func BreakMessage()
{
	var line_end = GetPipeKit();
	if (line_end) line_end->Report("$TxtPipeBroke$");
	return;
}

public func SaveScenarioObject(props)
{
	if (!inherited(props, ...)) return false;
	SaveScenarioObjectAction(props);
	return true;
}

/*-- Properties --*/

local Name = "$Name$";
local PipeMaxLength = 1200;

local ActMap = {
	Connect = {
		Prototype = Action,
		Name = "Connect",
		Procedure = DFA_CONNECT,
		NextAction = "Connect"
	}
};
